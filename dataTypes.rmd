## Datentypen

### Vektoren

#### Wozu Vektoren?

Vektoren, wie klingt das für Dich? Spannend, abschreckend, kompliziert,
wissenschftlich oder nach gymnasialer Oberstufe? Wie auch immer, es ist das
Feature in R, welches Du ziemlich bald in anderen Programmiersprachen vermissen
wirst, falls Du mit anderen Sprachen arbeitest.

Warum? So wissenschaftlich der Begriff auch klingen mag, der Vektor entspricht
ziemlich ganau dem, wie wir natürlicherweise über Dinge denken und wie wir über
den Umgang mit Dingen denken. Fast möchte ich sagen, er sei quasi neuronal.

Nehmen wir an, Du willst eine Party feiern, und hast eine Liste mit Leuten im
Kopf, die Du einladen willst. Da sagst dann, "**Jeder** bekommt eine Einladung.
Für **jeden** muss ich etwa 3 Flaschen Bier besorgen oder besser vier, usw.".
In Deiner Sprache und Deinen Gedanken kommen dabei keine Schleifen vor, wie Du
das organisiert. Du stellst Dir vor, wie Du das für eine Person tust und sagst
einfach **jeder**.

Genauso vereinfachen Vektoren die Programmierung. Du beschreibst die Lösung wie
für ein einzelnes Element, aber reichst gleich die ganze Liste hin, **jedes**
Element auf der Liste. Der Vektor ist also eine Auflistung gleichartiger
Elemente, die alle gleich verarbeitet werden, ohne dass Du zuerst eine Schleife
programmierst, um das einzelne Element verarbeiten zu können, wie in anderen
Sprachen.

Du sparst damit in R eine Menge Schleifenprogrammierung ein, ich schätze im
Vergleich bis 60%, je nachdem, was der Code tut. Der Code sieht damit viel
weniger technisch aus, sondern viel mehr wie gesprochene Sprache. Reden wir gar
nicht von der Zeit und der Suche nach Schleifenfehlern.

Wie ist das möglich? Erinnere Dich an die Oberstufe. Der Vektor packt eine
kleine Liste von Elementen zusammen, die alle gemeinsam verarbeitet werden
und zwar jedes in der gleichen Weise.

Der Vektor ist die kleinste Recheneinheit in R. Er hat eins oder merhrere
Elemente, aber Du kannst sie nicht aus dem Vektor nehmen. Wenn Du ein Element
aus dem Vektor nimmst, dann erhältst Du nämlich wieder einen Vektor und zwar
einen mit der Länge eins.

```{r}
lengthThreeVector <- c(1, 3, 5)
print(lengthThreeVector)
# Das Einzelelement aus Position 2 genommen ist auch wieder ein Vektor.
positionTwoVector <- lengthThreeVector[2]
is.vector(positionTwoVector) # Notiz: Der Punkt im Namen ist eher historisch als vorbildlich.
# Sogar dieses Ergebnis TRUE ist ein Vektor der Länge eins.

print(positionTwoVector)
```

Wenn Du einen Vektor mit sieben multiplizierst, dann wird jedes Element im
Vektor mit sieben multiplziert und das Ergebnis ist ein neuer Vektor. Wenn Du
jedes Element mit einem eigenen Wert multiplizieren willst, dann nimmst Du
einen zweiten Vektor, der diese Werte enthält. Du multiplziert beide Vektoren
und brauchst immer noch keine Schleife.

```{r}
c(2, 3) * 7
c(2, 3) * c(3, 4)
```

So praktisch dieser Ansatz auch ist, er funktioniert in R nur, aber immerhin,
sinnvoll für elementare, einheitliche Datentypen. Jedenfalls ist er nur dafür
implementiert. In der Datenwissenschaft verarbeiten wir typischerweise
Tabellen, in denen jede Spalte genau so eine einheitliche Liste elementarer
Typen darstellt. Deswegen ist dieser Ansatz in der Datenwissenschaft ungeheuer
produktiv. Es wäre interessant zu überlegen, wie weit er sich auch auf
komplexere Objekte ausdehnen liesse. Könnten wir dann weitgehend auf Schleifen
verzichten?

Ein verwandtes Verfahren Schleifen für komplexere Objekte zu vermeiden,
beinhaltet die Familie der Map-Funktionen, wenn auch nicht ganz so einfach
in der Anwendung wie Vektoren. Dazu ein eigenes Kapitel.

Hast Du schon einmal mit SQL gearbeitet? Dann werden Dir Parallelen auffallen.
Auch in SQL formulierst Du eine Instruktion so, als hättest Du es mit einem
einzelnen Datensatz zu tun. Dann wird die Instruktion auf alle Datensätze
angewendet. Dabei entspricht jede Spalte der Datenbank einem Vector.

> One observation I would make is that with vectorisation and
> subsetting, a lot of operations in R are more like SQL operations on
> databases than linear programming. If people can wrap their heads around
> that concept it often helps them he a good feel for why things are done
> in the way that they are.
>
> [David Hood on Coursera](https://class.coursera.org/repdata-034/forum/thread?thread_id=26)

#### Atomare Vektortypen

Atomare Vektoren erfüllen die Funktionen von skalaren Typen in anderen
Sprachen, aber mit den Features eines Vektors angereichert. R kennt diese
atomaren Vektortypen:

* logical
* integer
* double (Synonym "numeric")
* complex
* charakter
* raw

Literale Schreibweisen skalarer Typen erzeugen einen Vektor der Länge eins.

```{r}
length(FALSE)
is.vector(FALSE) # logical
is.vector(7L) # integer
is.vector(7.1) # double
is.vector(7) # double !!!
is.vector(3i) # complex
is.vector("Hallo") # character
is.vector(as.raw(15)) # raw, keine literale Schreibweise
```

Bei den literalen Schreibweisen musst Du also besonders beachten, dass auch die
einfache Schreibweise eines Integers `7` einen Vektor vom Typ *double* erzeugt.
Um einen Integer-Vektor zu erzwingen, stellst Du ein grosses **L** dahinter
`7L`.

**Aufgabe**: Schreibe für jeden der atomaren Vektortypen einen eigenen Wert und
teste ihn auf seinen Typ mit der Funktion `typeof()`, ob Du es richtig gemacht
hast.

Das **L** steht hier vermutlich für *long* im Vergleich zu *double*. Würdest Du
Dir die Wortpaare *integer* und *float* wünschen? Das ist aber leider nicht die
Terminologie von R. Prüfen wir, wie beide offiziell heissen:

```{r}
typeof(7L)
typeof(7)
class(7L)
class(7)
```
Das ist nicht gerade konsistent, nicht wahr, und sicherlich ein Hinweis auf die
Entwicklungsgeschichte von R. Welche Wortpaarung ist sprachlich sinvoller und
damit vermutlich jünger?

**Aufgabe**: Teste `7` und `7L` jeweils mit den Funktionen `is.integer()`,
`is.double()` und `is.numeric()`. Stimmt das Ergebnis mit Deinen Erwartungen
überein?

Der Vektortyp *raw* enthält binäre Daten und wird nicht literal eingegeben. Du
wirst ihn wohl eher selten verwenden. Angezeigt wird er als hexadezimaler Wert.

```{r}
as.raw(15)
```

Die verwandte hexadezimale literale Eingabe erzeugt dagegen keinen Vektor vom
Typ *raw*, sondern einen Vektor vom Typ *double*.

```{r}
typeof(0x0f)
```

##### Die Funktion Combine `c()`

Soweit haben wir uns jetzt  mit atomaren Vektoren der Länge eins beschäftigt
und bis hierher sehen sie einfach aus wie skalare Typen. Nützlich wird die
Natur des Vektors erst, wenn er länger als eins wird, wie in dieser Addition,
die jedes Element um eins erhöht.

```{r}
c(1, 2, 3) + 1
```

Wir wissen bereits, dass hier jeder Parameter ein atomarer Vektor der Länge
eins ist und auch die Kombination ist wieder ein Vektor.

```{r}
is.vector(c(1, 2, 3))
```

Offensichtlich fügt die Funktion `c()` die Parameter zu einem längeren Vektor
zusammen. Prüfen wir das doch einmal.

```{r}
length(c(3, 2, 1))
```

Wenn `c()` Vektoren der Länge eins zusammenfügt, kann es dann auch längere
Vektoren zusammen fügen? Natürlich! Es lässt sich beliebig verschachteln.

```{r}
c(c(1, 2), c(1, 2, c(3)), 4)
identical(c(1, 2, 1, 2, 3, 4), c(c(1, 2), c(1, 2, c(3)), 4))
```

Dabei wird die Gesamtreihenfolge nicht verändert. Wir sehen hier auch, dass
derselbe skalare Wert mehrfach in einem Vektor enthalten sein kann.

Was aber passiert, wenn wir unterschiedliche Typen zusammenfügen wollen?

```{r}
c("eins", 2)
```

Hättest Du eine Fehlermeldung erwartet? Die Funktion formt die übergebenen
Parameter sozusagen auf den kleinsten gemeinsamen Nenner um. Dieser ist hier
*character*. Diese automatische Typumwandlung nennt sich mit dem englischen
Fachbegriff **Type Conversion**.

Jeder Wert lässt ich im Zweifel in *character* umformen. Der Typ *character*
ist also die unterste Stufe dieser Hierarchie. Ganz oben steht *raw*. Der
niedrigste Datentyp in der folgenden Liste, der in den Parametern von `c()`
vertreten ist, wird als Kombinationstyp gewählt.

* raw
* logical
* integer
* double (Synonym "numeric")
* complex
* charakter

**Aufgabe**: Was erwartest Du als Ergebnis von `c(TRUE, 3i)`, `c(as.raw(15), TRUE)`
und `c(as.raw(0), "Hallo")`? Teste es.

**Dokumentation**: `?c`

##### Der Doppelpunkt Operator (Colon Operator)

Der **Colon Operator** ist eine Kurzschreibweise für die Funktion `seq(from,
to)`. Er ist ein sehr gängiges Verfahren, um eine Sequenz von Integer-Zahlen zu
erzeugen. In dieser Funktion wird er hier kurz angschnitten. Er wird
regelmässig in `for`-Schleifen eingesetzt.

```{r}
for(counter in 1:3) print(counter)
```

Betrachte jetzt den Vektor selbst.

```{r}
1:10
```

Du schreibst ihn in der Regel nicht mit Integern `1L:10L`, sondern mit Doubles.
Das ist kürzer zu schreiben. Was denkst Du welcher Typ von Vektor erzeugt wird?

```{r}
typeof(1:10)
```

Ist das nicht überraschend? Rufe diese beiden Hilfeseiten auf und finde heraus,
warum das so ist:

* `?":"`
* `?seq`

Kurz gesagt, wenn sich die erste Zahl auf einen Integer reduzieren lässt, dann
ist der Rückgabewert ein Integer, andernfalls nicht.

```{r}
1.1:5
typeof(1.1:5)
```

Hier sehen wir auch, dass die zweite Zahl eine Obergrenze ist, aber nicht immer
im Ergebnis selbst enthalten ist. Die Sequenz muss auch nicht immer mit `1`
beginnen und kann auch abwärts zählen.

**Aufgabe**: Probiere folgende Varianten aus:

* `2:4`
* `1L:10L`
* `10:1`
* `10:-10`
* `pi:10`


##### Teilmengen von Vektoren

#### Listen

### NA und NAN

### Wahr und falsch

### Text

### Zahlen

### Funktionen
