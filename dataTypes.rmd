## Datentypen

### Vektoren

#### Wozu Vektoren?

Vektoren, wie klingt das für Dich? Spannend, abschreckend, kompliziert,
wissenschftlich oder nach gymnasialer Oberstufe? Wie auch immer, es ist das
Feature in R, welches Du ziemlich bald in anderen Programmiersprachen vermissen
wirst, falls Du mit anderen Sprachen arbeitest.

Warum? So wissenschaftlich der Begriff auch klingen mag, der Vektor entspricht
ziemlich ganau dem, wie wir natürlicherweise über Dinge denken und wie wir über
den Umgang mit Dingen denken. Fast möchte ich sagen, er sei quasi neuronal.

Nehmen wir an, Du willst eine Party feiern, und hast eine Liste mit Leuten im
Kopf, die Du einladen willst. Da sagst dann, "**Jeder** bekommt eine Einladung.
Für **jeden** muss ich etwa 3 Flaschen Bier besorgen oder besser vier, usw.".
In Deiner Sprache und Deinen Gedanken kommen dabei keine Schleifen vor, wie Du
das organisiert. Du stellst Dir vor, wie Du das für eine Person tust und sagst
einfach **jeder**.

Genauso vereinfachen Vektoren die Programmierung. Du beschreibst die Lösung wie
für ein einzelnes Element, aber reichst gleich die ganze Liste hin, **jedes**
Element auf der Liste. Der Vektor ist also eine Auflistung gleichartiger
Elemente, die alle gleich verarbeitet werden, ohne dass Du zuerst eine Schleife
programmierst, um das einzelne Element verarbeiten zu können, wie in anderen
Sprachen.

Du sparst damit in R eine Menge Schleifenprogrammierung ein, ich schätze im
Vergleich bis 60%, je nachdem, was der Code tut. Der Code sieht damit viel
weniger technisch aus, sondern viel mehr wie gesprochene Sprache. Reden wir gar
nicht von der Zeit und der Suche nach Schleifenfehlern.

Wie ist das möglich? Erinnere Dich an die Oberstufe. Der Vektor packt eine
kleine Liste von Elementen zusammen, die alle gemeinsam verarbeitet werden
und zwar jedes in der gleichen Weise.

Der Vektor ist die kleinste Recheneinheit in R. Er hat eins oder merhrere
Elemente, aber Du kannst sie nicht aus dem Vektor nehmen. Wenn Du ein Element
aus dem Vektor nimmst, dann erhältst Du nämlich wieder einen Vektor und zwar
einen mit der Länge eins.

```{r}
lengthThreeVector <- c(1, 3, 5)
lengthThreeVector
# Das Einzelelement aus Position 2 genommen ist auch wieder ein Vektor.
positionTwoVector <- lengthThreeVector[2]
is.vector(positionTwoVector) # Notiz: Der Punkt im Namen ist eher historisch als vorbildlich.
# Sogar dieses Ergebnis TRUE ist ein Vektor der Länge eins.

positionTwoVector
```

Wenn Du einen Vektor mit sieben multiplizierst, dann wird jedes Element im
Vektor mit sieben multiplziert und das Ergebnis ist ein neuer Vektor. Wenn Du
jedes Element mit einem eigenen Wert multiplizieren willst, dann nimmst Du
einen zweiten Vektor, der diese Werte enthält. Du multiplziert beide Vektoren
und brauchst immer noch keine Schleife.

```{r}
c(2, 3) * 7
c(2, 3) * c(3, 4)
```

So praktisch dieser Ansatz auch ist, er funktioniert in R nur, aber immerhin,
sinnvoll für elementare, einheitliche Datentypen. Jedenfalls ist er nur dafür
implementiert. In der Datenwissenschaft verarbeiten wir typischerweise
Tabellen, in denen jede Spalte genau so eine einheitliche Liste elementarer
Typen darstellt. Deswegen ist dieser Ansatz in der Datenwissenschaft ungeheuer
produktiv. Es wäre interessant zu überlegen, wie weit er sich auch auf
komplexere Objekte ausdehnen liesse. Könnten wir dann weitgehend auf Schleifen
verzichten?

Ein verwandtes Verfahren Schleifen für komplexere Objekte zu vermeiden,
beinhaltet die Familie der Map-Funktionen, wenn auch nicht ganz so einfach
in der Anwendung wie Vektoren. Dazu ein eigenes Kapitel.

Hast Du schon einmal mit SQL gearbeitet? Dann werden Dir Parallelen auffallen.
Auch in SQL formulierst Du eine Instruktion so, als hättest Du es mit einem
einzelnen Datensatz zu tun. Dann wird die Instruktion auf alle Datensätze
angewendet. Dabei entspricht jede Spalte der Datenbank einem Vector.

> One observation I would make is that with vectorisation and
> subsetting, a lot of operations in R are more like SQL operations on
> databases than linear programming. If people can wrap their heads around
> that concept it often helps them he a good feel for why things are done
> in the way that they are.
>
> [David Hood on Coursera](https://class.coursera.org/repdata-034/forum/thread?thread_id=26)

#### Atomare Vektortypen

Atomare Vektoren erfüllen die Funktionen von skalaren Typen in anderen
Sprachen, aber mit den Features eines Vektors angereichert. R kennt diese
atomaren Vektortypen:

* logical
* integer
* double (Synonym "numeric")
* complex
* charakter
* raw

Literale Schreibweisen skalarer Typen erzeugen einen Vektor der Länge eins.

```{r}
length(FALSE)
is.vector(FALSE) # logical
is.vector(7L) # integer
is.vector(7.1) # double
is.vector(7) # double !!!
is.vector(3i) # complex
is.vector("Hallo") # character
is.vector(as.raw(15)) # raw, keine literale Schreibweise
```

Bei den literalen Schreibweisen musst Du also besonders beachten, dass auch die
einfache Schreibweise eines Integers `7` einen Vektor vom Typ *double* erzeugt.
Um einen Integer-Vektor zu erzwingen, stellst Du ein grosses **L** dahinter
`7L`.

**Aufgabe**: Schreibe für jeden der atomaren Vektortypen einen eigenen Wert und
teste ihn auf seinen Typ mit der Funktion `typeof()`, ob Du es richtig gemacht
hast.

Das **L** steht hier vermutlich für *long* im Vergleich zu *double*. Würdest Du
Dir die Wortpaare *integer* und *float* wünschen? Das ist aber leider nicht die
Terminologie von R. Prüfen wir, wie beide offiziell heissen:

```{r}
typeof(7L)
typeof(7)
class(7L)
class(7)
```
Das ist nicht gerade konsistent, nicht wahr, und sicherlich ein Hinweis auf die
Entwicklungsgeschichte von R. Welche Wortpaarung ist sprachlich sinvoller und
damit vermutlich jünger?

**Aufgabe**: Teste `7` und `7L` jeweils mit den Funktionen `is.integer()`,
`is.double()` und `is.numeric()`. Stimmt das Ergebnis mit Deinen Erwartungen
überein?

Der Vektortyp *raw* enthält binäre Daten und wird nicht literal eingegeben. Du
wirst ihn wohl eher selten verwenden. Angezeigt wird er als hexadezimaler Wert.

```{r}
as.raw(15)
```

Die verwandte hexadezimale literale Eingabe erzeugt dagegen keinen Vektor vom
Typ *raw*, sondern einen Vektor vom Typ *double*.

```{r}
typeof(0x0f)
```

##### Die Funktion Combine `c()`

Soweit haben wir uns jetzt  mit atomaren Vektoren der Länge eins beschäftigt
und bis hierher sehen sie einfach aus wie skalare Typen. Nützlich wird die
Natur des Vektors erst, wenn er länger als eins wird, wie in dieser Addition,
die jedes Element um eins erhöht.

```{r}
c(1, 2, 3) + 1
```

Wir wissen bereits, dass hier jeder Parameter ein atomarer Vektor der Länge
eins ist und auch die Kombination ist wieder ein Vektor.

```{r}
is.vector(c(1, 2, 3))
```

Offensichtlich fügt die Funktion `c()` die Parameter zu einem längeren Vektor
zusammen. Prüfen wir das doch einmal.

```{r}
length(c(3, 2, 1))
```

Wenn `c()` Vektoren der Länge eins zusammenfügt, kann es dann auch längere
Vektoren zusammen fügen? Natürlich! Es lässt sich beliebig verschachteln.

```{r}
c(c(1, 2), c(1, 2, c(3)), 4)
identical(c(1, 2, 1, 2, 3, 4), c(c(1, 2), c(1, 2, c(3)), 4))
```

Dabei wird die Gesamtreihenfolge nicht verändert. Wir sehen hier auch, dass
derselbe skalare Wert mehrfach in einem Vektor enthalten sein kann.

Was aber passiert, wenn wir unterschiedliche Typen zusammenfügen wollen?

```{r}
c("eins", 2)
```

Hättest Du eine Fehlermeldung erwartet? Die Funktion formt die übergebenen
Parameter sozusagen auf den kleinsten gemeinsamen Nenner um. Dieser ist hier
*character*. Diese automatische Typumwandlung nennt sich mit dem englischen
Fachbegriff **Type Conversion**.

Jeder Wert lässt ich im Zweifel in *character* umformen. Der Typ *character*
ist also die unterste Stufe dieser Hierarchie. Ganz oben steht *raw*. Der
niedrigste Datentyp in der folgenden Liste, der in den Parametern von `c()`
vertreten ist, wird als Kombinationstyp gewählt.

* raw
* logical
* integer
* double (Synonym "numeric")
* complex
* charakter

**Aufgabe**: Was erwartest Du als Ergebnis von `c(TRUE, 3i)`, `c(as.raw(15), TRUE)`
und `c(as.raw(0), "Hallo")`? Teste es.

**Dokumentation**: `?c`

##### Der Doppelpunkt Operator (Colon Operator)

Der **Colon Operator** ist eine Kurzschreibweise für die Funktion `seq(from,
to)`. Er ist ein sehr gängiges Verfahren, um eine Sequenz von Integer-Zahlen zu
erzeugen. In dieser Funktion wird er hier kurz angschnitten. Er wird
regelmässig in `for`-Schleifen eingesetzt.

```{r}
for(counter in 1:3) print(counter)
```

Betrachte jetzt den Vektor selbst.

```{r}
1:10
```

Du schreibst ihn in der Regel nicht mit Integern `1L:10L`, sondern mit Doubles.
Das ist kürzer zu schreiben. Was denkst Du welcher Typ von Vektor erzeugt wird?

```{r}
typeof(1:10)
```

Ist das nicht überraschend? Rufe diese beiden Hilfeseiten auf und finde heraus,
warum das so ist:

* `?":"`
* `?seq`

Kurz gesagt, wenn sich die erste Zahl auf einen Integer reduzieren lässt, dann
ist der Rückgabewert ein Integer, andernfalls nicht.

```{r}
1.1:5
typeof(1.1:5)
```

Hier sehen wir auch, dass die zweite Zahl eine Obergrenze ist, aber nicht immer
im Ergebnis selbst enthalten ist. Die Sequenz muss auch nicht immer mit `1`
beginnen und kann auch abwärts zählen.

**Aufgabe**: Probiere folgende Varianten aus:

* `2:4`
* `1L:10L`
* `10:1`
* `10:-10`
* `pi:10`

##### Vektorelemente lesen, bearbeiten und löschen

Du hast jetzt gelernt, wie Du atomare Vektoren erzeugst. Wenn Du Daten
verabeitest sind Vektoren Teil des Inputs. Um sie zu verabeiten, ist es jetzt
wichtig zu lernen, wie Du sie veränderst und Teilmengen daraus heraus ziehtst.

Fangen wir damit an, ein einzelnes Element zu lesen. Wir sprechen es mit seinem
Index an.

```{r}
input <- c("eins", "zwei", "drei", "vier")
input[3]
```

Was passiert, wenn Du mit einem negativen Index arbeitst? Wird dann von hinten
gezählt? Probiere es!

```{r}
input[-3]
```

Was ist denn das? Du erhältst einen Negativabdruck des Vorstehenden. Statt des
indizierten Elementes aus dem Vektor, erhältst Du den Vektor ohne das negativ
indizierte Element.

Jetzt verändern wir ein einzelnes Element im Vektor.

```{r}
input[3] <- "DREI"
input
```

Genau wie bei *Colon Operator* schreibst Du hier wieder *doubles*, weil sich
das kürzer schreibt, obwohl der Index eine klassische Integer-Sequenz ist.
Beweisen wir also, dass ein echter Integer-Vektor auch als Selektor
funktioniert.

```{r}
input[3L] <- "drei"
input
```

**Aufgabe**: Nimm die Zahl `pi` als Selektor. Welches Ergebnis erwartest Du?

Bis hierher haben wir einen Vektor der Länge eins als Selektor genommen. Wenn
Du die Idee der Vektoren verstanden hast, fragst Du dich sicher schon, was
passiert, wenn Du einen längeren Vektor verwendest, z.B. `c(1, 4)`. Probiere
es aus!

```{r}
input[c(1,4)]
```

Das ist doch mal logisch! Du kannst jetzt verallgemeinern und sagen, dass Du in
den eckigen Klammern von *input* einen Vektor übergibst, der die Elemente
indiziert, die Du als Teilmenge von *input* erhalten willst.

Wie das für die Negativauswahl funktioniert, kannst Du jetzt auch ableiten.

```{r}
input[-c(1,4)]
```

Ganz im Geiste von Vektoren kannst Du jetzt auch mehrere Elemente in einer
einzigen Instruktion ersetzen. Cool!

```{r}
input[c(2,3,4)] <- c("ZWEI", "DREI", "VIER")
input
```

Erinnere Dich, dass Du den Vektor `c(2L, 3L, 4L)` auch mit dem *Colon Operator*
erzeugen kannst, als `2:4`! In den eckinge Klammern entfaltet das seine volle
Magie.

```{r}
input[2:4] <- c("zwei", "drei", "vier")
input
```

Zeigen wir, dass wir in den Eckigen Klammern nicht nur die Elemente
selektieren, sondern auch ihre Reihenfolge festlegen können. Jetzt zählen
wir rückwärts.

```{r}
input[4:2]
```

**Zusammenfassung**: Datenverabeiteung ist vollständig, wenn der CRUD-Zyklus
vollständig ist, nämlich *create*, *read*, *update* und *delete*.

```{r}

# create:
words <- c("eins", "zwei", "drei", "vier")

# update:
words[1:2] <- c("EINS", "ZWEI")

# delete:
words <- words[-(2:3)]

# read:
words[2:1]
```

Das Löschen wird also durchgeführt, indem man die reduzierte Teilmenge in die
alte Variable schreibt. Gerade hierführ eignet sich die Negativauswahl
besonders gut, weil man dabei einfach die zu löschenden Elemente aufzählt.

**Aufgabe**: Spiele den CRUD-Zypklus für einen Zahlenvektor durch. Beachte
dabei, dass sich beim Löschen der Index verkürzt.

**Dokumentation**: `?"["`

##### Vektorelemente mit logischen Vektoren selektieren

Du hast Vektorelemente im vorigen Abschnitt über ihren Index selektiert, als
Positivauswahl oder als Negativauswahl. Eine Alternative dazu ist die Auswahl
mittels logischer Vektoren. Vergleiche die beiden folgenden Methoden.

```{r}
planets <- c("Merkur", "Venus", "Erde", "Mars")
planets[c(2, 4)]
planets[c(FALSE, TRUE, FALSE, TRUE)]
```

In beiden Fällen ist die Auswahl dieselbe. Während Du im ersten Fall nur die
positiven Elemente über ihren Index aufzählst, musst Du im zweiten Fall für
jedes einzelne Element angeben, ob es berücksichtigt werden soll oder nicht.

Warum solltest Du das tun? Es so zu schreiben macht wenig Sinn. Eine logische
Abfrage gegen einen Vekotor gibt aber einen logischen Vektor zurück, mit dem Du
dann so etwas tun kannst.

Hier benutzen wir den Modulo-Operator, um ungrade Zahlen zu finden und
speichern den logischen Vektor in die Variable `odd`.  Den logischen Vektor
`odd` verwenden wir dann als Selektor der Zahlen.

```{r}

numbers <- 10:20
odd <- numbers %% 2 > 0
odd
numbers[odd]
```

Das geht natürlich auch ohne die Zwischenspeicherung in die Variable `odd`.

```{r}
numbers[numbers %% 2 > 0]
```

Vielleicht nimmst Du daran Anstoss, dass Du hier `numbers` zwei mal schreiben
musst. Damit hast Du im Sinne einer menschenorientierten Lesbarkeit vollkommen
recht. Wendet man R so an wie hier, dann wird es ziemlich kryptisch.

Bei diesem Gebrauch können die eckigen Klammern nicht wissen, dass der logische
Vektor aus derselben Menge berechnet wurde, wie der Nummernvektor selbst. Daher
musst Du `numbers` zwei mal schreiben.

Es ähnelt einer mathematischen Formel, in der diesebe Variable mehrfach
vorkommt, und aus der Mathematik stammmen die eckigen Klammern ja auch. Wie in
anderen Programmiersprachen auch, gehören sie aber so sehr zu den Grundlagen,
dass sie bald zur zweiten Natur werden.

Hier will ich auch noch einmal auf die Verwandschaft zwischen Vektoren und
Tabellenspalten in SQL hinweisen.

```
SELECT numbers FROM table WHERE numbers %% 2 > 0
```

**Aufgabe**: Mische die Zahlen von 1 bis 100 `numbers <- sample(100)`. Benutze
einen logischen Vektor, um alle Zahlen heraus zu ziehen, die grösser als 50
sind, wobei die Zufallsreihenfolge erhalten bleiben soll.

#### Listen

### NA und NAN

### Wahr und falsch

### Text

### Zahlen

### Funktionen
