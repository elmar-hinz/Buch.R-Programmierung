<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ist das Dein Buch?</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Ist das Dein Buch?</h2>

<p>Du willst also R lernen? Cool! Dafür kann es manche Gründe geben, aber sehr
wahrscheinlich willst Du R in Zukunft benutzen, um Daten zu analysieren und zu
visualisieren. Wenn Du dieses Buch liest, hast Du Dich bereits grundlegend über
R informiert.</p>

<p>Damit dieses Buch ein durchgängiges Anspruchsniveau erhält, muss ich mir
Gedanken über seine Leser machen, über Dich, darüber, was ich an Wissen und
Erfahrung voraussetzen kann. Es macht natürlich einen grossen Unterschied, ob
Du bereits mit anderen Sprachen gearbeitet hast oder mit R ganz neu in die Welt
Programmierung einsteigst. Beide Szenarios schätze ich als häufig ein. Ist das
also Dein Buch?</p>

<p>Das Buch ist primär dazu gedacht, R zu lernen, sekundär als möglicher Einstieg
in die Programmierung. Wenn Du bereits Erfahrung mit anderen Sprachen gesammelt
hast, macht das die Dinge einfacher, weil Du die Denkmuster und die
Terminologie bereits kennst.</p>

<p>Ich versuche die Beispiele einfach genug zu halten, dass Du auch ohne vorherige
Programmiererfahrung dem Buch folgen kannst. Das setzt aber eine sehr aktive
Herangehensweise von Deiner Seite voraus, denn das Programmieren lernst Du nur
indem Du es tust.</p>

<p>Erstens solltest Du Begriffe, die Dir fremd sind nachschlagen, z.B. mittels
Wikipedia. Zweitens brauchst Du eine spielerische, aktive Herangehensweisea.
Du musst viel ausprobieren, auch wenn Dich das Buch nicht direkt dazu
auffordert, also aus eigenem Antrieb, bis Du fühlst, die Idee verstanden zu
haben. Drittens brauchst Du den Mut Kapitel, die du nicht sofort verstehst, zu
überspringen und das vor zu ziehen, was Dir zugänglicher erscheint.</p>

<p>Wenn diese aktive Herangehensweise nicht Deinem Naturell entspricht, empfehle
ich, die Grundlagen des Programmierens auf andere Weise zu lernen, insbesondere
in einem Kursus unter Anleitung. Solche Kurse als Einstieg in die
Programmierung findest Du häufiger für andere Sprachen, wie Python, Java oder
JavaScript. Die Denkmuster und Arbeitstechniken sind übertragbar. Die modernen
Programmiersprachen sind sich ähnlicher als Du denkst.</p>

<p>Als Nachschlagewerk ist dieses Buch nicht gedacht. R hat eine gut
Online-Hilfe zum Nachschlagen der Funktionen. Rezepte für Problemstellungen
findest Du sowieso am besten mit Hilfe einer Suchmaschine.</p>

<h2>Einführung</h2>

<h3>Hallo Welt in R</h3>

<pre><code class="r">print(&quot;Hallo Welt!&quot;)
</code></pre>

<pre><code>## [1] &quot;Hallo Welt!&quot;
</code></pre>

<p>Bist Du enttäuscht? Nichts Neues im Vergleich zu anderen Sprachen?  R ist eben
leicht zu lernen.</p>

<p>Charakteristisches für R zeigt dieses kleine Programm. Wir berechen die
Oberflächen meherer Planeten anhand ihres Radius, ohne dass eine Schleife
nötig wird.</p>

<pre><code class="r">names &lt;- c(&quot;Merkur&quot;, &quot;Venus&quot;, &quot;Erde&quot;, &quot;Mars&quot;)
radii &lt;- c(2440, 6052, 6371, 3389)
surfaces &lt;- round(4 * pi * radii^2 / 1000) * 1000
paste(names, &quot;:&quot;, radii, &quot;km, &quot;, surfaces, &quot;km^2&quot;)
</code></pre>

<pre><code>## [1] &quot;Merkur : 2440 km,  74815000 km^2&quot; &quot;Venus : 6052 km,  460265000 km^2&quot;
## [3] &quot;Erde : 6371 km,  510064000 km^2&quot;  &quot;Mars : 3389 km,  144329000 km^2&quot;
</code></pre>

<p>Davon machen wir noch - quick and dirty - einen explorativen Plot, um zu sehen,
wie die Fläche im Quadrat ansteigt.</p>

<pre><code class="r">plot(radii, surfaces)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk planetsPlot"/> </p>

<p>Wie viel Zeilen Code wäre in anderen Sprachen nötig, um Listen von Daten zu
berechnen und in einem Diagramm zu visualieren?</p>

<h3>Was ist R?</h3>

<blockquote>
<p>R is a free software environment for statistical computing and graphics.
It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS.</p>

<p><a href="https://www.r-project.org">https://www.r-project.org</a></p>
</blockquote>

<ul>
<li>R ist eine Multiparadigmensprache:

<ul>
<li>dynamisch</li>
<li>funktional</li>
<li>eingeschränkt objektorientiert</li>
</ul></li>
<li>R ist eine freie Software Sammlung

<ul>
<li>für statisiche Berechnungen und ihre Visualisierung</li>
<li>mit Interpreter, Shell, IDE und Bibliotheken</li>
<li>die unter Unix, MacOs und Windows benutzt werden kann</li>
</ul></li>
<li>R ist in vielen Bereichen der Wissenschaft der de facto Standard zur
Erstellung und Veröffentlichung von statistischen Forschungsergebnissen.</li>
<li>R ist ein Werkzeug, das als Schnittstelle von grossen IT-Firmen in ihre
Produkte implementiert wird.</li>
</ul>

<h3>Was macht R besonders?</h3>

<p>Zwei der besondere Stärken von R hast Du gerade kennen gerlernt. Erstens die
unkomplizierte Weise, ganze Listen von Daten so einfach zu verarbeiten, als sei
das ein einzelner Wert, zweitens die komfortablen Möglichkeiten, Daten als
Diagramme zu visualisieren. R ist zudem auf allen verbreiteten Betriebssystemen
einsetzbar, nämlich Linux, MacOS und Windows. Das ist vor allem im Vergleich
mit Exel ein Vorteil, nicht zuletzt im Hinblick auf die Reproduzierbarkeit von
Studien.</p>

<p>R versucht dem möglichst nahe zu kommen, wie der Wissenschaftler denkt.
Einerseits sind das nicht unbedingt Schleifen, wie beim Programmierer.
Andererseits sind das zum Beispiel die Zuweisungsoperatoren &ldquo;&lt;-&rdquo;, wie sie
in der wissenschaftlichen Schreibweise gebräuchlich sind.</p>

<p>Wie bei anderen Sprachen auch, ist vieles gewachsen und begründet sich dann
als &ldquo;historisch bedingt&rdquo;. Zur Geschichte gibt es noch ein eigenes Kapitel.</p>

<p>Das Alleinstellungsmerkmal von R sind aber sicherlich die umfangreichen
frei verfügbaren Bibliotheken, die dem Wissenschaftler zur Verfügung stehen,
um Daten aufzuarbeiten, zu analysiern und zu visualisieren. Auch wie
das getan wird, ist wissenschaftlich fundiert. Die Schritte folgen
definierten Grammatiken.</p>

<p>Natürlich verabeiten alle Programmiersprachen Daten. Entscheidend ist also,
wie die Daten betrachtet und genutzt werden. In der Wissenschaft steht der
Erkenntnisgewinn im Vordergrund. Charakteristisch sind die Umformung der
Daten, die Analyse und die Visualisierung.</p>

<p>Vergleicht man das mit Twitter, steht dort der Transport und die Vervielfältigung
von Textnachrichten im Vordergrund, was zu anderen Anforderungen an die Software
führt. Vergleicht man das mit einem Betriebssystem, steht dort die Anbindung
der Hardware im Vordergrund, sowie die Aufteilung der Rechenzeit, was wiederum
ganz andere Anforderungen an die Software stellt.</p>

<p>Im Regelfall lädt R die Daten komplett in den Arbeitsspeicher, bevor es mit der
weiteren Verarbeitung beginnt. Das hat den Vorteil, dass Du sehr schnell und
flexibel auch mit grossen Datenmengen jonglieren kannst, Stichwort Exploration.
Für Twitter oder ein Betriebssystem wäre diese Herangehensweise gar nicht
möglich, weil die Daten kontinuierlich strömen. Mit diesem Feature setzt sich R
also zugleich auch eine wichtige Grenze. Für die Verabeitung von Datenstömen
ist R nicht optimiert.</p>

<h3>Ist R eine Programmiersprache oder ein Werkzeug?</h3>

<blockquote>
<p>R is a free software environment for statistical computing and graphics.
It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS.</p>

<p><a href="https://www.r-project.org">https://www.r-project.org</a></p>

<p>R is more than a programming language. It is an interactive
environment for doing statistics. I find it more helpful to think of R as
having a programming language than being a programming language. The R
language is the scripting language for the R environment, just as VBA is the
scripting language for Microsoft Excel. Some of the more unusual features of
the R language begin to make sense when viewed from this perspective.&ldquo;</p>

<p><a href="http://www.johndcook.com/blog/r_language_for_programmers/">John D. Cook</a></p>
</blockquote>

<p>Die offizielle Definition lautet, R ist eine Entwicklungsumgebung für
statistische Berechnungen und Graphiken. John D. Cook gibt die sehr
diplomatische Definition, R sei eine Entwicklungsumgebung mit einer
Skriptsprache und damit mehr als eine Programmiersprache.</p>

<p>Tatsächlich stellt sich die Frage, wie weit R auch eine allgemein einsetzbare
Programmiersprache ist im Vergleich zu Java, C oder C++. Sicherlich ist es
heute noch nicht so allgemein einsetzbar, wie weitreichend es aber einsetzbar
ist, darauf fällt die Antwort sehr unterschiedlich aus, je nach Blickwinkel.</p>

<p>Oft lautet auch Frage auch, was im Bereich der Datenwissenschaft die bessere
Sprache ist, Python oder R. R hat in diesem Bereich die umfangreichere
Werkzeugsammlung, die Infrastruktur von Python ist breiter aufgestellt und kann
damit besser Brücken schlagen. In der Bioinformatik bespielsweise, wo
Algorithmen stärker im Vordergrung stehen als Datentabellen, Statistiken und
Diagramme, gibt es eine höhere Affinität zu Python. Beide Sprachen sind so
leicht zu lernen, dass nichts dagegen spricht sie gemeinsam einzusetzten.
Schliesslich werden Konzepte zur Datenberechnung, die sich in R bewährt haben
auch in Python übernommen, so dass die Grenzen zwischen beiden Sprachen
abnehmen.</p>

<p>Die Sprache alleine ist auch nicht das alles Entscheidende. Genauso wichtig
sind die verfügbaren Bibliotheken, Interpreter und Compiler, um das optimale
Einsatzgebiet einer Sprache zu bestimmen. R wurde von Wissenschaftleren für
Wissenschaftler entwickelt und gepflegt. Das hat das Profil der vorhandenen
Werkzeuge geprägt. Datenanalyse wird aber auch in weiten Bereichen der
Wirtschaft, der Politik oder des Journalismus immer wichtiger. Ensprechend
weitet sich aus das Spektrum der Bibliotheken aus.</p>

<p>R ist heute u.a. geeignet, um datenzentierte Artikel und Bücher zu verfassen.
Dieses Buch ist mithilfe solcher Bibliotheken erstellt. Es enstehen
Bibliotheken, die die Veröffentlichung als Webseiten oder als mobile Apps
unterstützen, mit zunehmenden interaktiven Möglichkeiten. IBM, Oracle,
Microsoft, SAP, etc. implementieren Schnittstellen, um R als Werkzeug einbinden
zu können.</p>

<p>Im Vergleich zu Java oder C++ ist R als universelle Programmiersprache heute
noch weniger geeignet. Erstens ist sind seine objektorientieren Möglichkeiten
noch nicht voll entwickelt, zweitens sind seine Bibliotheken sehr spezialisert
und drittens setzt sein Speicherverhalten konzeptionlle Grenzen, die aber
überwindbar sind.</p>

<p>R besetzte eine verwandte Lücke, für die Perl ursprünglich konzeptioniert war,
als &quot;Practical Extraction and Report Language&rdquo;. Perl hat diese Nische
unerwartet verlassen und wurde die erste Sprache der Internet Programmierung.
In der Folge wurde es auf beiden Gebieten abgelöst, u.a wegen seiner Grenzen
bei der Objektorientieren Programmierung und der zu langsamen Erneuerung der
Sprache, aber vielleicht auch wegen des Verlustes seiner Spezialisierung. Wir
finden Parallelen in R, sowohl bei den Chancen als auch bei den Risiken. Die
Unterstützung durch Industrie und Wissenschaft ist aber viel umfassender als in
der Geschichte von Perl.</p>

<h3>Die R-Infrastruktur</h3>

<h3>Die Geschichte von R</h3>

<h2>Los geht&#39;s</h2>

<h3>Hardware Anforderungen</h3>

<h3>Installation</h3>

<h4>R</h4>

<h4>R Studio</h4>

<h3>Programmausführung</h3>

<p>R ist eine interpretierte Sprache. Ein Programm muss nicht als Ganzes
kompiliert werden um ausfürbar zu sein. Stattdessen wird eine Instruktion nach
der anderen entgegengenommen und direkt ausgeführt. Diese Instruktionen können
entweder einzeln in der Shell eingegeben oder als Liste in eine Datei
geschrieben werden. Damit erhältst Du dann ein Programmskript.</p>

<h4>Shell</h4>

<p>In der Shell gibtst Du Instruktionen ein, die Du nur einmalig ausführen willst
und nicht speichern. Beispiele sind:</p>

<ul>
<li>Aufruf von Programmenskripten.</li>
<li>Aufruf der Hilfe.</li>
<li>Austesten von Funktionen, um mehr über R zu lernen.</li>
<li>Testen von Programmschnipseln, bevor Du sie in Dateien einfügst.</li>
<li>Exploration von Daten. Nur was brauchbar ist, schreibst Du in Dateien.</li>
<li>Benutzung der Shell als wissenschaftlicher Taschenrechner.</li>
</ul>

<p>Es kann also sinnvoll sein, mehrere Shells parallel zu benutzen.</p>

<h4>Dateien</h4>

<p>Alles, was Du wiederholt ausführen oder aufheben willst, schreibst Du in
Dateien.  Das fängt beim Austesten mehrzeiliger Programmschnipsel, die du so
oft ausführst, bis sie funktionieren.</p>

<h4>Bibliotheken</h4>

<p>Bibliotheken sind Dateien, die Funktionen enthalten, die Du aus verschiedenen
Programmen heraus immer wieder benutzen willst. Entweder Du schreibst sie
selbst oder Du lädst Bibliotheken aus öffentlichen und privaten Repositories.</p>

<h4>IDE RStudio</h4>

<p>IDE heisst <em>integrated development environment</em>. <em>RStudio</em> integriert nicht nur
Shell und Editor für Programmscripte, sondern zeigt zum Beispiel auch direk die
erzeugten Diagramme an. Sie vereint also die verschiedenen Möglichkeiten zur
Programmausführung, mit weiteren nützlichen Werkzeugen.</p>

<h3>Hilfe</h3>

<h2>Syntax</h2>

<h3>Kommentare</h3>

<p>Kommentare werden in R wie in Bash, Python oder Perl mit einer Raute
eingeleitet. Kommentare dienen der Dokumentation. Die Zeilen werden
nicht ausgeführt.</p>

<pre><code class="r"># Dies ist ein Kommentar.

################################################################################
# Dies ist ein Kommentar über mehrere Zeilen. Die Rahmenbalken sind 80 Zeichen
# lang. Sie werden auch mit einer Raute eingeleitet und sind daher einfach
# ein Kommentar.
################################################################################

# Ein mehrzeiliger Kommentar muss natürlich nicht immer solche Rahmenbalken
# haben. Ein solcher Rahmen eigent sich gut für das Copyright im Seitenkopf
# einer Datai oder als Kopf über einer Funktionsdefinition. Auch um wichtige
# Hinweise zu betonen, ist ein Rahmen geeignet.

print(&quot;Hallo Welt!&quot;) # Der Kommentar kann auch hinter einer Instruktion stehen.
</code></pre>

<pre><code>## [1] &quot;Hallo Welt!&quot;
</code></pre>

<p>Eine Raute innerhalb eines Strings ist kein Kommentar.</p>

<pre><code class="r">print(&quot;Das Zeichen # ist hier Bestandteil des Strings.&quot;)
</code></pre>

<pre><code>## [1] &quot;Das Zeichen # ist hier Bestandteil des Strings.&quot;
</code></pre>

<p>Schreibt die Raute dagegen vor eine Instruktion, so wird die Instruktion selbst
zum Kommentar und damit nicht mehr ausgeführt. Das ist ein gängiges Mittel, um
Bereiche im Programmcode vorrübergehend auszuschalten. Man nennt es
Auskommentieren.</p>

<pre><code class="r"># print(&quot;Dies wird nicht ausgegeben.&quot;)
</code></pre>

<h3>Instruktionen</h3>

<p>Instruktionen werden wie in C mittels Semicolon getrennt.</p>

<pre><code class="r">x &lt;- &quot;Hallo Welt!&quot;; print(x);
</code></pre>

<pre><code>## [1] &quot;Hallo Welt!&quot;
</code></pre>

<p>Am Zeilenende können diese ausgelassen werden. Das ist die Regel.</p>

<pre><code class="r">x &lt;- &quot;Hallo Welt!&quot;
print(x)
</code></pre>

<pre><code>## [1] &quot;Hallo Welt!&quot;
</code></pre>

<h3>Blöcke und Einrückungen</h3>

<p>Programmcode wird in Bereiche eingeteilt, die gezielt ausführbar sind. Ein
solcher Bereich wird Block genannt und besteht aus mehreren Zeilen von
Instruktionen. Beispiele solcher Blöcke sind Funktionen, Schleifen oder die
unterschiedlichen Zweige von If-Else-Bedingungen. Daraus ergibt sich, dass die
Blöcke verschachtelt auftreten, wenn z.B. eine Funktion eine Schleife enthält.</p>

<pre><code class="r"># Ein Funktionsblock, der einen Schleifenblock enthält.
show &lt;- function() {
    for(i in 1:3) {
        print(i);
    }
}
show()
</code></pre>

<pre><code>## [1] 1
## [1] 2
## [1] 3
</code></pre>

<p>Wie werden solche Blöcke nun definiert?</p>

<p>Drei Techniken sind bei Programmiersprachen verbreitet, erstens Schlüsselworte
(Keywords), zweitens Einrückungstiefen (Indentation, Off-Side-Rule), drittens
geschweifte Klammern. Keywords wurden bereits in den 1950er von ALGOL benutzt.
Heute findest Du sie z.B. in Ruby und Bash. Off-Side-Rule wird u.a. verwendet
von Python, YAML und CoffeScript und lässt sich bis ins Jahr 1966 zurück
verfolgen. Die geschweiften Klammern wurden 1972 mit C eingeführt und haben
heute eine weite Verbreitung so in C++, Java, C#, JavaScript, Perl oder Go.</p>

<p>R verwendet geschweifte Klammern wie C. Gerade mit einer deutschen Tastatur
sind diese Klammern lästig zu tippen und einrückem muss man den Code für die
Lesbarkeit genau so wie bei der Off-Side-Rule. Es ist vor allem mehr Arbeit. Im
Vergleich zur Off-Side-Rule sieht ein solcher Text viel technischer und damit
schlechter lesbar aus.</p>

<pre><code class="r"># Nicht hübsch, aber lauffähig.
# Die geschweiften Klammern begrenzen die Code-Blöcke.
# Einrückungen dienen in R allein der besseren Lesbarkeit.
show &lt;- function() { for(i in 1:3) { print(i); } }; show();
</code></pre>

<pre><code>## [1] 1
## [1] 2
## [1] 3
</code></pre>

<p>Warum verwendet R geschweifte Klammern und warum sind
sie so weit verbreitet?</p>

<p>Sicherlich hat C einen grossen normativen Einfluss ausgeübt, gerade in der Zeit
als die Sprache entworfen wurde. Geschweifte Klammern sind im Vergleich zum
Whitespace von Einrückungen leichter zu parsen. Fehler sind seltener. Gerade
in grossen Projekten sind Fehler, die durch Einrückungsfehler entstehen,
schwierig zu finden. Werden Sprachen gemischt wird es mit Einrückungen
besonders schwierig.</p>

<p>Fazit: Unterm Strich ist es etwas bedauerlich, dass R nicht wie Python Off-Side-Rule verwendet. Zu lang sind die Skripte eigentlich nicht.</p>

<h4>Blöcke sind Instruktionen</h4>

<h3>Variablen</h3>

<p>Variablennamen folgen grundsätzlich den Mustern verbreiteter Sprachen.</p>

<ul>
<li>Namen bestehen aus Buchstaben, Ziffern, Unterstrichen oder Punkten.</li>
<li>Namen starten mit einem Buchstaben oder mit einem Punkt.</li>
<li>Nach einem anführenden Punkt darf keine Ziffer folgen (falsch: .2x).</li>
<li>Reservierte Worte dürfen nicht verwendet werden.</li>
</ul>

<p>Reservierte Worte sind kein Thema. Du erkennst Konflikte automatisch an der
Fehlermeldung.</p>

<p>Das Überraschende ist der Punkt als gültiger Bestandteil von Variablennamen. In
anderen Sprachen werden damit Elemente eines Objektes angesprochen. Das
geschieht in R dagegen ziemlich eigentümlich mittels des Dollarzeichens.</p>

<pre><code class="r">a &lt;- list(&quot;alpha&quot; = 1, &quot;beta&quot; = 2) # Variable a befüllt mit einer Liste.
a.dot &lt;- &quot;Punkt&quot; # Eine unabhängige Variable, die nur aussieht wie Teil von a.
print(a) # Die Liste a enthält nicht &quot;Punkt&quot; und wurde auch nicht überschrieben.
</code></pre>

<pre><code>## $alpha
## [1] 1
## 
## $beta
## [1] 2
</code></pre>

<pre><code class="r">print(a.dot) # &quot;Punkt&quot; wird unabhängig ausgegeben.
</code></pre>

<pre><code>## [1] &quot;Punkt&quot;
</code></pre>

<pre><code class="r">print(a$beta) # Mit dem $-Zeichen wird ein Element von a angesprochen.
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">print(a$dot) # Dieses gibt es dagegen nicht.
</code></pre>

<pre><code>## NULL
</code></pre>

<p><strong>Tip</strong>: Wenn Du Verwirrungen mit anderen Sprachen minimieren willst,
verwendest Du den Punkt als Worttrenner nicht. Er ist eher eine Erblast als ein
Feature. Die besseren Alternativen sind <em>unter_strich</em> oder <em>CamelCase</em>.</p>

<p>Der Punkt als Namensbestandteil, wird Dir aber gerade in den fundamentalen und
daher besonders alten Funktionen und Parametern begegnen, das heist häufig.
Häufiges Sehen verleitet dazu, es zu kopieren. Ich betrachte es dagegen als
Chance meine Funktionen von den internen zu unterscheiden.</p>

<h3>Zuweisungen</h3>

<p>Kurz gesagt, die Zuweisung zu Variablen erfolgt in R mittels des
Zuweisungsoperators <code>&lt;-</code>  während die Zuweisung zu Funktionsparametern und zu
Namen in Listen und Data-Frames mit dem Gleichheitszeichen <code>=</code> erfolgt.</p>

<p>Dieses Beispiel zeigt die Anwendung von <code>&lt;-</code> und <code>=</code>.</p>

<pre><code class="r">################################################################################
# Create a dataframe with calculated planet data.
#
# @param names Characters of names.
# @param radii Numbers of radii in km.
# @return data.frame
##
setupPlanets &lt;- function(names, radii, star = &quot;Sonne&quot;) {
     data.frame(
        Name = names,
        Star = star,
        Radius = radii,
        Diameter = 2 * radii,
        Perimeter = 2 * pi * radii,
        Surface = 4 * pi * radii^2,
        Volume =  4/3 * pi * radii^3
    )
 }

input &lt;- list(
    names = c(&quot;Merkur&quot;, &quot;Venus&quot;, &quot;Erde&quot;, &quot;Mars&quot;),
    radii = c(2440, 6052, 6371, 3389)
)
planets &lt;- setupPlanets(radii = input$radii, names = input$names)
print(planets)
</code></pre>

<pre><code>##     Name  Star Radius Diameter Perimeter   Surface       Volume
## 1 Merkur Sonne   2440     4880  15330.97  74815144 6.084965e+10
## 2  Venus Sonne   6052    12104  38025.84 460264737 9.285074e+11
## 3   Erde Sonne   6371    12742  40030.17 510064472 1.083207e+12
## 4   Mars Sonne   3389     6778  21293.72 144328800 1.630434e+11
</code></pre>

<p>Hier definiere ich eine Funktion und weise sie der Variablen <code>setupPlanets</code>
mittels des <code>&lt;-</code>-Operators zu.  Das speichern ganzer Funktionen in Variablen
charakterisiert eine funktionale Programmiersprache. Eine solche Zuweisung
erfolgt auch bei den Variablen <code>input</code> und <code>planets</code>, denen eine Liste bzw.
einen Data-Frame zugewiesen wird.</p>

<p>Sowohl beim Data-Frame als auch bei der Liste werden die einzelnen benannten
Elemente mittels <code>=</code> zugewiesen.</p>

<p>Das Gleichheitszeichen verwende ich auch, um den Parameter <code>star</code> bei der
Funktionsdefinition mit einem Default-Wert vorzubelegen, hier <code>&quot;Sonne&quot;</code>.
Beim Funktionsaufruf dient mir das Gleichheitszeichen schließlich dazu, die
Parameter mit ihrem Namen statt mit ihrer Reihenfolge an zu sprechen.  Hier
habe ich die Reihenfolge vertauscht, um das zu demonstrieren.</p>

<h4>Diskussion der Alternativen</h4>

<p>Es ist oft, aber eben nicht immer, technisch möglich Variablen mittels <code>=</code>
statt mittels <code>&lt;-</code> zuzuweisen. Weil das ein Zeichen weniger zu tippen ist und
den Zuweisungen in vielen anderen Programmiersprachen entspricht, wird Dir das
im Code vieler Leute begegnen. Um einen klaren, einheitlichen Programmierstil
zu pflegen, solltest Du aber konsequent <code>&lt;-</code> für die Zuweisung von Variablen
benutzen. Das ist einfach R-stylisch.</p>

<p>Die Zuweisung mittels <code>&lt;--</code> ist möglich, aber für die Zuweisung an
übergeordnete Sichtbarkeitsbereiche gedacht. Du musst wissen, was du hiermit
tust. Dazu mehr im Kapitel über die Sichtbarkeitsbereiche.</p>

<p><code>-&gt;</code> macht genau dasselbe wie <code>&lt;-</code>. Nicht dass Du denkst die Variable käme dann
nach rechts. Es ist also nicht intuitiv verständlich.</p>

<p>Analog ist <code>--&gt;</code> dasselbe <code>&lt;--</code> und nicht intuitiv verständlich.</p>

<p>Also:</p>

<ul>
<li><code>=</code> Ist nicht überall einsetzbar und nicht R-stylisch.</li>
<li><code>-&gt;</code> Ist verwirrend.</li>
<li><code>&lt;--</code> Du solltest wissen, was Du tust.</li>
<li><code>--&gt;</code> Ist verwirrent und Du solltest wissen, was Du tust.</li>
</ul>

<p><strong>Tip</strong>: Variablenzuweisung mittels <code>&lt;-</code> bevorzugen.</p>

<h3>Namensräume</h3>

<p>Variablen können bereits Funktionen oder Daten enthalten, auch die aus
den Basis-Paketen und die aus den Bibliotheken, die Du lädst.</p>

<p>Du musst also
aufpassen, dass Du keine Namen von Funktionen oder Daten überschreibst,
jedenfalls nicht solche, die Du später noch verwenden willst.</p>

<p>Tust Du es doch, dann kannst du die Variablen der Pakte aber immer noch über
ihren Full Qualified Name ansprechen. Das kann einerseits lohnenswert sein, um
einen sprechenden Variablennamen wie &ldquo;data&rdquo; frei einsetzen zu können,
andererseits  kann es auch eingefleischte R-Benutzer verwirren, wenn der
vertraute Name &ldquo;zweckentfremdet&rdquo; wird.</p>

<pre><code class="r"># Die Funktion print ist im Paket base
base::print(&quot;Hallo&quot;)
</code></pre>

<pre><code>## [1] &quot;Hallo&quot;
</code></pre>

<pre><code class="r"># Das Paket base ist per default geladen.
# Darum kann base::print() verkürzt angesprochen werden.
print(&quot;Hallo&quot;)
</code></pre>

<pre><code>## [1] &quot;Hallo&quot;
</code></pre>

<pre><code class="r"># Die Variable print wird hier mit einer Funktion definiert.
print &lt;- function(...) { &quot;Nope&quot; }
# Was passiert jetzt?
print(&quot;Welt&quot;)
</code></pre>

<pre><code>## [1] &quot;Nope&quot;
</code></pre>

<pre><code class="r"># Der Fully Qualified Name funktioniert weiterhin.
base::print(&quot;Welt&quot;)
</code></pre>

<pre><code>## [1] &quot;Welt&quot;
</code></pre>

<pre><code class="r"># Definition aufheben.
remove(print)
# Jetzt wird wieder base::print() angesprochen.
print(&quot;Welt&quot;)
</code></pre>

<pre><code>## [1] &quot;Welt&quot;
</code></pre>

<h3>Coding Guidelines</h3>

<p>Es gibt keine verbindlichen Coding Guidlines für R, was sicherlich auch mit
dem freien Geist der Wissenschaft zusammenhängt. Gerade im Hinblick auf die
wachsenden Ansprüche an die Reproduzierbarkeit von Studien, werden Standards
aber auch hier wichtiger. Darum möchte ich ein paar Empfehlungen aussprechen,
die sich aus anderen Bereichen herleiten lassen.</p>

<p>Klarheit, Einheitlichkeit und Dokumentation sind Elemente, die Du in Deinem
Programmcode anstreben solltest. Klarheit und Einheitlichkeit helfen Dir und
anderen, sich schnell und einfach in Deinem Code zu orientieren. Dokumentation
hilft, die Gedanken nachzuvollziehen, die zu Deinen Programmlösungen führen.
Alles das hilft auch Bugs zu vermeiden, zu finden und zu fixen.</p>

<p>Unter Dokumentation verstehe ich zuerst die Wahl sprechender Namen für Deine
Variablen, zu allererst die der Funktionsnamen. Je mehr Dein Programmcode der
gesprochenen Sprache nahe kommt, desto weniger musst Du in zusätlichen
Kommentaren erklären. Kryptischer Programmcode ist kein Zeichen einer
überlegenen Intelligenz, wie in den Kinofilmen gezeigt, sondern von
suboptimalen Bezeichnern. Desto einfacher andere Deinen Code nachvollziehen
können, desto besser ist Deine Arbeit und desto weniger Fehler wird er
enthalten.</p>

<p>Es ist eine gute Idee, einheitlich englische Bezeichner zu verwenden. Erstens
hast Du dann niemals Probleme mit Umlauten, zweitens sind englische Bezeichner
fast immer kürzer als deutsche und drittens arbeitest Du heute zuhnemend in
internationalen Teams. Wenn Du aber deutsche Bezeichner benutzen willst, dann
solltest Du auch darin möglichst konsequent sein.</p>

<p>Auch wenn Dozenten Variablen wie x, y, z benutzen, sollte so etwas nicht in
Deinem Code vorkommen, sondern ganze Worte. Wichtig ist, dass Du die
Autovervollständigung Deines Editors kennen lernst, damit Du nicht jedes
Zeichen einzeln tippen musst. Das spart Zeit und Tippfehler.</p>

<p>Sprechende Bezeichner bestehen oft aus zwei oder noch mehr Worteilen. Darum ist
es wichtig, wie Du Diese zusammenfügst. Für eine gute Lesbarkeit haben sich
CamelCase oder die Benutzung des Unterstriches bewährt. Bei drei Wortteilen
spart CamelCase im Vergleich zwei Unterstriche an Zeilenlänge. Da Deine Zeilen
80 Zeichen im Regelfall nicht überschreiten sollten, halte ich CamelCase für
vorteilhafter.</p>

<pre><code class="r">################################################################################
# Diese Kommentarbalken sind 80 Zeichen lang.
################################################################################

speakingWordExample = &quot;kürzer&quot; # CamelCase, sehr gut.
speaking_word_example = &quot;länger&quot; # Unterstrich, auch gut.
speakingwordexample = &quot;schwer lesbar&quot; # mangelhaft
nswe = &quot;Aküfi&quot; # So sprichst Du hoffentlich nicht den ganzen Tag.
s = &quot;wie in Mathe&quot; # Jetzt versteht Dich nur noch der Prozessor.
</code></pre>

<p>80 Zeichen sind ein allgemeiner Richtwert, wie lang Programmzeilen sein
sollten. Damit kannst Du auf einem normalen Monitor gut zwei Dateien
nebeneinader öffnen inklusive Zeilennummern. Wenn Du professionell arbeitest,
ist ein solcher Split-View eher die Regel als die Ausnahme, besonders dann,
wenn Du Code und Tests side-by-side erstellst. Diese Breite ist auch im
Hinblick auf eine einfache Fokussierbarkeit des Textes wichtig. Bei längeren
Zeilen wird es anstrengend, beim Lesen in der richtigen Zeile zu bleiben.</p>

<p>Den Programmcode solltest Du entsprechend seiner Blocktiefe einrücken. Ob du
das mittels Leerzeichen oder Tabs tust, ist Geschmacksache. Beides hat vor und
Nachteile. Wichtig ist, dass Dein Team und Du hier eine einheitliche Richtlinie
festlegen, weil beides durcheinander schlecht funktioniert.</p>

<p>Der verbreitetste Standard bei den Einrückungen sind 8 Zeichen. Bei vier Ebenen
sind dann aber schon 32 von 80 Zeichen damit verbraucht. Wenn Du zuammengestzte
Worte als Bezeichner verwendest, bist schnell am Ende der Zeile. Was tun?</p>

<ol>
<li>Gute Bezeichner sind wichtiger als tiefe Einrückungen. Ich halte darum vier
Zeichen bei den Einrückungen für sinnvoller.</li>
<li>Verschachtelungen von 4 Tiefen sind in der Regel ein Zeichen von zu langen
und komplexen Funktionen. Meist kannst Du dann ganze Code-Blöcke in eigene
Funktionen auslagern und erhälst damit ein besseres Ergebnis. Funktionen
sollten selten länger als zwanzig Zeilen sein.</li>
<li>Wenn der Platz nicht ausreicht, dann brich die Zeile um und rücke die zweite
Zeile noch einmal eine Ebene ein. Du kannst in R aber nicht an beliebigen
Stellen umbrechen, weil das Zeilenende als Semicolon fehlinterpretiert
werden kann. So lange Du innerhalb einer geöffneten Klammer umbrichst, z.B.
innerhalb der Funktionsparameter, erkennt R, dass hier kein Instruktionsende
sein kann. Probiere einfach etwas herum, bis Du das routiniert meisterst.</li>
</ol>

<p>Auch wenn Du konsequent ganze Worte als Variablennamen verwendest, solltest Du
immer noch Kommentare schreiben. Kommentare innerhalb von Funktionen sollten
dann aber so gut wie überflüssig werden. Oberhalb von Funktionen sollte ein
einheitlich formatierter Kommentar stehen, der in der Regel 4 Angaben macht:</p>

<ol>
<li>Titel der Funktion</li>
<li>Beschreibung, was die Funktion tut (kann bei Banalitäten fehlen).</li>
<li>Beschreibung jedes einzelnen Parameters.</li>
<li>Rückgabewert der Funktion.</li>
</ol>

<pre><code class="r">################################################################################
# Do nothing
#
# This function does nothing. It just exists,
# that you have something to call.
#
# @param Integer Defaults to 43.
# @param ...     Eats up any additional parameters that you feed into.
# @return NULL
##
doNothing &lt;- function(dummy = 43, ...) {
    NULL
}
</code></pre>

<p>Dein Code sieht aufgeräumt aus, wenn du wie in diesem Beispiel einen
einheitlichen Rahmen um den Funktionskommentar zeichnest. Ich wähle auch hier
eine Länge von 80 Zeichen, um dem Leser eine Fokussionshilfe zu geben.</p>

<p>In R sind Funktionen, die in Variablen gespeicherst sind, zwar auch Objekte, In
dem Moment, in dem die sie aufrufst, werden sie aber akitiv. Sie sind die
Verben deines Programmcodes. Darum solltest Du sie auch immer mit Verben
bennen. Der Standard ist, dazu den Imperativ zu verwenden, so wie im
vorstehenden Beispiel <code>doNothing()</code>. Andere Beispiele wären <code>getName()</code>,
<code>setName()</code>, <code>createTable()</code>, <code>translateToSomeThing()</code>, <code>format()</code>,
<code>showResult()</code>.</p>

<p>Eine Ausnahme sind Funktionen, die <code>TRUE</code> oder <code>FALSE</code> zurück geben. Sie
werden am besten wie Fragen formuliert, so dass sie in <code>if</code>-Verzweigungen oder
<code>while</code>-Schleifen sprachlich Sinn ergeben.</p>

<pre><code class="r">if(isChild(person)) {
    print(&quot;Kein Zugang&quot;)
}

while(hasMoreElements(iterator)) {
    print(getNextElement(iterator))
}
</code></pre>

<p>Das Beispiel <code>doNothing()</code> zeigt auch, dass der erste Buchstabe immer klein
sein sollte, auch bei CamelCase. Das gilt sowohl für Werte als auch für
Funktionen. Eine sinnvolle Ausnahme sind Funktionen, die wie Klassen in
anderen Sprachen verwendet werden. Dazu später.</p>

<h2>Datentypen</h2>

<h3>Vektoren</h3>

<h4>Wozu Vektoren?</h4>

<p>Vektoren, wie klingt das für Dich? Spannend, abschreckend, kompliziert,
wissenschftlich oder nach gymnasialer Oberstufe? Wie auch immer, es ist das
Feature in R, welches Du ziemlich bald in anderen Programmiersprachen vermissen
wirst, falls Du mit anderen Sprachen arbeitest.</p>

<p>Warum? So wissenschaftlich der Begriff auch klingen mag, der Vektor entspricht
ziemlich ganau dem, wie wir natürlicherweise über Dinge denken und wie wir über
den Umgang mit Dingen denken. Fast möchte ich sagen, er sei quasi neuronal.</p>

<p>Nehmen wir an, Du willst eine Party feiern, und hast eine Liste mit Leuten im
Kopf, die Du einladen willst. Da sagst dann, &ldquo;<strong>Jeder</strong> bekommt eine Einladung.
Für <strong>jeden</strong> muss ich etwa 3 Flaschen Bier besorgen oder besser vier, usw.&rdquo;.
In Deiner Sprache und Deinen Gedanken kommen dabei keine Schleifen vor, wie Du
das organisiert. Du stellst Dir vor, wie Du das für eine Person tust und sagst
einfach <strong>jeder</strong>.</p>

<p>Genauso vereinfachen Vektoren die Programmierung. Du beschreibst die Lösung wie
für ein einzelnes Element, aber reichst gleich die ganze Liste hin, <strong>jedes</strong>
Element auf der Liste. Der Vektor ist also eine Auflistung gleichartiger
Elemente, die alle gleich verarbeitet werden, ohne dass Du zuerst eine Schleife
programmierst, um das einzelne Element verarbeiten zu können, wie in anderen
Sprachen.</p>

<p>Du sparst damit in R eine Menge Schleifenprogrammierung ein, ich schätze im
Vergleich bis 60%, je nachdem, was der Code tut. Der Code sieht damit viel
weniger technisch aus, sondern viel mehr wie gesprochene Sprache. Reden wir gar
nicht von der Zeit und der Suche nach Schleifenfehlern.</p>

<p>Wie ist das möglich? Erinnere Dich an die Oberstufe. Der Vektor packt eine
kleine Liste von Elementen zusammen, die alle gemeinsam verarbeitet werden
und zwar jedes in der gleichen Weise.</p>

<p>Der Vektor ist die kleinste Recheneinheit in R. Er hat eins oder merhrere
Elemente, aber Du kannst sie nicht aus dem Vektor nehmen. Wenn Du ein Element
aus dem Vektor nimmst, dann erhältst Du nämlich wieder einen Vektor und zwar
einen mit der Länge eins.</p>

<pre><code class="r">lengthThreeVector &lt;- c(1, 3, 5)
print(lengthThreeVector)
</code></pre>

<pre><code>## [1] 1 3 5
</code></pre>

<pre><code class="r"># Das Einzelelement aus Position 2 genommen ist auch wieder ein Vektor.
positionTwoVector &lt;- lengthThreeVector[2]
is.vector(positionTwoVector) # Notiz: Der Punkt im Namen ist eher historisch als vorbildlich.
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># Sogar dieses Ergebnis TRUE ist ein Vektor der Länge eins.

print(positionTwoVector)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<p>Wenn Du einen Vektor mit sieben multiplizierst, dann wird jedes Element im
Vektor mit sieben multiplziert und das Ergebnis ist ein neuer Vektor. Wenn Du
jedes Element mit einem eigenen Wert multiplizieren willst, dann nimmst Du
einen zweiten Vektor, der diese Werte enthält. Du multiplziert beide Vektoren
und brauchst immer noch keine Schleife.</p>

<pre><code class="r">c(2, 3) * 7
</code></pre>

<pre><code>## [1] 14 21
</code></pre>

<pre><code class="r">c(2, 3) * c(3, 4)
</code></pre>

<pre><code>## [1]  6 12
</code></pre>

<p>So praktisch dieser Ansatz auch ist, er funktioniert in R nur, aber immerhin,
sinnvoll für elementare, einheitliche Datentypen. Jedenfalls ist er nur dafür
implementiert. In der Datenwissenschaft verarbeiten wir typischerweise
Tabellen, in denen jede Spalte genau so eine einheitliche Liste elementarer
Typen darstellt. Deswegen ist dieser Ansatz in der Datenwissenschaft ungeheuer
produktiv. Es wäre interessant zu überlegen, wie weit er sich auch auf
komplexere Objekte ausdehnen liesse. Könnten wir dann weitgehend auf Schleifen
verzichten?</p>

<p>Ein verwandtes Verfahren Schleifen für komplexere Objekte zu vermeiden,
beinhaltet die Familie der Map-Funktionen, wenn auch nicht ganz so einfach
in der Anwendung wie Vektoren. Dazu ein eigenes Kapitel.</p>

<p>Hast Du schon einmal mit SQL gearbeitet? Dann werden Dir Parallelen auffallen.
Auch in SQL formulierst Du eine Instruktion so, als hättest Du es mit einem
einzelnen Datensatz zu tun. Dann wird die Instruktion auf alle Datensätze
angewendet. Dabei entspricht jede Spalte der Datenbank einem Vector.</p>

<blockquote>
<p>One observation I would make is that with vectorisation and
subsetting, a lot of operations in R are more like SQL operations on
databases than linear programming. If people can wrap their heads around
that concept it often helps them he a good feel for why things are done
in the way that they are.</p>

<p><a href="https://class.coursera.org/repdata-034/forum/thread?thread_id=26">David Hood on Coursera</a></p>
</blockquote>

<h4>Atomare Vektortypen</h4>

<p>Atomare Vektoren erfüllen die Funktionen von skalaren Typen in anderen
Sprachen, aber mit den Features eines Vektors angereichert. R kennt diese
atomaren Vektortypen:</p>

<ul>
<li>logical</li>
<li>integer</li>
<li>double (Synonym &ldquo;numeric&rdquo;)</li>
<li>complex</li>
<li>charakter</li>
<li>raw</li>
</ul>

<p>Literale Schreibweisen skalarer Typen erzeugen einen Vektor der Länge eins.</p>

<pre><code class="r">length(FALSE)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">is.vector(FALSE) # logical
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(7L) # integer
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(7.1) # double
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(7) # double !!!
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(3i) # complex
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(&quot;Hallo&quot;) # character
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">is.vector(as.raw(15)) # raw, keine literale Schreibweise
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Bei den literalen Schreibweisen musst Du also besonders beachten, dass auch die
einfache Schreibweise eines Integers <code>7</code> einen Vektor vom Typ <em>double</em> erzeugt.
Um einen Integer-Vektor zu erzwingen, stellst Du ein grosses <strong>L</strong> dahinter
<code>7L</code>.</p>

<p><strong>Aufgabe</strong>: Schreibe für jeden der atomaren Vektortypen einen eigenen Wert und
teste ihn auf seinen Typ mit der Funktion <code>typeof()</code>, ob Du es richtig gemacht
hast.</p>

<p>Das <strong>L</strong> steht hier vermutlich für <em>long</em> im Vergleich zu <em>double</em>. Du würdest
Dir vermutlich das Wording <em>integer</em> und <em>float</em> wünschen. Das ist aber leider
nicht die Terminologie von R. Prüfen wir, wie beide offiziell heissen:</p>

<pre><code class="r">typeof(7L)
</code></pre>

<pre><code>## [1] &quot;integer&quot;
</code></pre>

<pre><code class="r">typeof(7)
</code></pre>

<pre><code>## [1] &quot;double&quot;
</code></pre>

<pre><code class="r">class(7L)
</code></pre>

<pre><code>## [1] &quot;integer&quot;
</code></pre>

<pre><code class="r">class(7)
</code></pre>

<pre><code>## [1] &quot;numeric&quot;
</code></pre>

<p>Das ist nicht gereade konsistent und sicherlich ein Hinweis auf die
Entwicklungsgeschichte von R. Welche Wortpaarung ist sprachlich sinvoller
und damit vermutlich jünger?</p>

<p><strong>Aufgabe</strong>: Teste <code>7</code> und <code>7L</code> jeweils mit den Funktionen <code>is.integer()</code>,
<code>is.double()</code> und <code>is.numeric()</code>. Stimmt das Ergebnis mit deinen Erwartungen
überein?</p>

<p>Der Vektortyp <em>raw</em> enthält binäre Daten und wird nicht literal eingegeben. Du
wirst ihn wohl eher selten verwenden. Angezeigt wird er als hexadezimaler Wert.</p>

<pre><code class="r">as.raw(15)
</code></pre>

<pre><code>## [1] 0f
</code></pre>

<p>Die verwandte hexadezimale literale Eingabe erzeugt dagegen keinen Vektor vom
Typ <em>raw</em>, sondern einen Vektor vom Typ <em>double</em>.</p>

<pre><code class="r">typeof(0x0f)
</code></pre>

<pre><code>## [1] &quot;double&quot;
</code></pre>

<h5>Die Funktion Combine <code>c()</code></h5>

<p>Soweit haben wir uns jetzt  mit atomaren Vektoren der Länge eins beschäftigt
und bis hierher sehen sie einfach aus wie skalare Typen. Nützlich wird die
Natur des Vektors erst, wenn er länger als eins wird, wie in dieser Addition
die jedes Element um eins erhöht.</p>

<pre><code class="r">c(1, 2, 3) + 1
</code></pre>

<pre><code>## [1] 2 3 4
</code></pre>

<p>Wir wissen bereits, dass hier jeder Parameter ein atomarer Vektor der Länge
eins ist und auch die Kombination ist wieder ein Vektor.</p>

<pre><code class="r">is.vector(c(1, 2, 3))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Offensichtlich fügt die Funktion <code>c()</code> die Parameter zu einem längeren Vektor
zusammen.  Prüfen wir das.</p>

<pre><code class="r">length(c(3, 2, 1))
</code></pre>

<pre><code>## [1] 3
</code></pre>

<p>Wenn <code>c()</code> Vektoren der Länge eins zusammenfügt, kann es dann auch längere
Vektoren zusammen fügen? Natürlich! Es lässt sich beliebig verschachteln.</p>

<pre><code class="r">c(c(1, 2), c(1, 2, c(3)), 4)
</code></pre>

<pre><code>## [1] 1 2 1 2 3 4
</code></pre>

<pre><code class="r">identical(c(1, 2, 1, 2, 3, 4), c(c(1, 2), c(1, 2, c(3)), 4))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Dabei wird die Gesamtreihenfolge nicht verändert. Wir sehen hier auch, dass
derselbe skalare Wert mehrfach in einem Vektor enthalten sein kann.</p>

<p>Was aber passiert, wenn wir unterschiedliche Typen zusammenfügen wollen?</p>

<pre><code class="r">c(&quot;eins&quot;, 2)
</code></pre>

<pre><code>## [1] &quot;eins&quot; &quot;2&quot;
</code></pre>

<p>Hättest Du eine Fehlermeldung erwartet? Die Funktion formt die übergebenen
Parameter sozusagen auf den kleinsten gemeinsamen Nenner um. Dieser ist hier
<em>character</em>.</p>

<p>Jeder Wert lässt ich im Zweifel in <em>character</em> umformen. Der Typ <em>character</em>
ist also die unterste Stufe dieser Hierarchie. Ganz oben steht <em>raw</em>. Der
niedrigste Datentyp in der folgenden Liste, der in den Paramtern von <code>c()</code>
vertreten ist, wird als Kombinationstyp gewählt.</p>

<ul>
<li>raw</li>
<li>logical</li>
<li>integer</li>
<li>double (Synonym &ldquo;numeric&rdquo;)</li>
<li>complex</li>
<li>charakter</li>
</ul>

<p><strong>Aufgabe</strong>: Was erwartest Du als Ergebnis von <code>c(TRUE, 3i)</code>, <code>c(as.raw(15), TRUE)</code>
und <code>c(as.raw(0), &quot;Hallo&quot;)</code>? Teste es.</p>

<p><strong>Dokumentation</strong>: <code>?c</code></p>

<h5>Sequenzen</h5>

<h5>Teilmengen von Vektoren</h5>

<h4>Listen</h4>

<h3>NA und NAN</h3>

<h3>Wahr und falsch</h3>

<h3>Text</h3>

<h3>Zahlen</h3>

<h3>Funktionen</h3>

<h2>Operatoren</h2>

<h2>Kontrollstrukturen</h2>

<h2>Komplexe Datentypen</h2>

<h3>Matrix</h3>

<h3>Data Frame</h3>

<h2>Sichtbarkeitsbereiche (Scopes)</h2>

<h3>Lexikalische Sichtbarkeitsbereiche</h3>

<h3>Closures</h3>

<h3>Klassen und Objekte</h3>

<h2>Functionals</h2>

<h2>Testen</h2>

<h2>Bibliotheken</h2>

<h3>dplyr</h3>

<h3>ggplot2</h3>

<h3>knitr</h3>

</body>

</html>
