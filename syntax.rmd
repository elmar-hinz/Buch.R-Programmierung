## Syntax

### Kommentare

Kommentare werden in R wie in Bash, Python oder Perl mit einer Raute
eingeleitet.

```{r comments}

# Dies ist ein Kommentar.

##################################################
# Dies ist ein Kommentar
# über mehrere Zeilen.
##################################################

print("Hallo Welt!") # Der Kommentar kann auch dahinter stehen.

```

### Instruktionen

Instruktionen werden wie in C mittels Semicolon getrennt.

```{r}
x <- "Hallo Welt!"; print(x);
```

Am Zeilenende können diese ausgelassen werden.

```{r}
x <- "Hallo Welt!"
print(x)
```

### Blöcke und Einrückungen

Programmcode wird in Bereiche eingeteilt, die gezielt ausführbar sind. Ein
solcher Bereich wird Block genannt und besteht aus mehreren Zeilen von
Instruktionen. Beispiele solcher Blöcke sind Funktionen, Schleifen oder die
unterschiedlichen Zweige von If-Else-Bedingungen. Daraus ergibt sich, dass die
Blöcke verschachtelt auftreten, wenn z.B. eine Funktion eine Schleife enthält.

```{r blocks}
# Ein Funktionsblock, der einen Schleifenblock enthält.
show <- function() {
    for(i in 1:3) {
        print(i);
    }
}
show()
```

Wie werden solche Blöcke nun definiert?

Drei Techniken sind bei Programmiersprachen verbreitet, erstens Schlüsselworte
(Keywords), zweitens Einrückungstiefen (Indentation, Off-Side-Rule), drittens
geschweifte Klammern. Keywords wurden bereits in den 1950er von ALGOL benutzt.
Heute findest Du sie z.B. in Ruby und Bash. Off-Side-Rule wird u.a. verwendet
von Python, YAML und CoffeScript und lässt sich bis ins Jahr 1966 zurück
verfolgen. Die geschweiften Klammern wurden 1972 mit C eingeführt und haben
heute eine weite Verbreitung so in C++, Java, C#, JavaScript, Perl oder Go.

R verwendet geschweifte Klammern wie C. Gerade mit einer deutschen Tastatur
sind diese Klammern lästig zu tippen und einrückem muss man den Code für die
Lesbarkeit genau so wie bei der Off-Side-Rule. Es ist vor allem mehr Arbeit. Im
Vergleich zur Off-Side-Rule sieht ein solcher Text viel technischer und damit
schlechter lesbar aus.


```{r blocks2}
# Einrückungen dienen in R nur der Lesbarkeit. Das funktioniert genau so.
show <- function() { for(i in 1:3) { print(i); } }; show();
```

Warum verwendet R geschweifte Klammern und warum sind
sie so weit verbreitet?

Sicherlich hat C einen grossen normativen Einfluss ausgeübt, gerade in der Zeit
als die Sprache entworfen wurde. Geschweifte Klammern sind im Vergleich zum
Whitespace von Einrückungen leichter zu parsen. Fehler sind seltener. Gerade
in grossen Projekten sind Fehler, die durch Einrückungsfehler entstehen,
schwierig zu finden. Werden Sprachen gemischt wird es mit Einrückungen
besonders schwierig.

Fazit: Unterm Strich ist es etwas bedauerlich, dass R nicht wie Python Off-Side-Rule verwendet. Zu lang sind die Skripte eigentlich nicht.

#### Blöcke sind Instruktionen

### Variablen

Variablennamen folgen grundsätzlich den Mustern verbreiteter Sprachen.

* Namen bestehen aus Buchstaben, Ziffern, Unterstrichen oder Punkten.
* Namen starten mit einem Buchstaben oder mit einem Punkt.
* Nach einem anführenden Punkt darf keine Ziffer folgen (falsch: .2x).
* Reservierte Worte dürfen nicht verwendet werden.

Reservierte Worte sind kein Ding. Du erkennst das automatisch an der
Fehlermeldung.

Das überraschende ist der Punkt als gültiger Bestandteil von Variablennamen. In
anderen Sprachen werden damit Elemente eines Objektes angesprochen. Das
geschieht in R mittels des Dollarzeichens.

```{r}
a <- list("alpha" = 1, "beta" = 2) # Variable a befüllt mit einer Liste.
a.dot <- "Punkt" # Eine unabhängige Variable, die nur aussieht wie Teil von a.
print(a) # Die Liste a enthält nicht "Punkt" und wurde auch nicht überschrieben.
print(a.dot) # "Punkt" wird unabhängig ausgegeben.
print(a$beta) # Mit dem $-Zeichen wird ein Element von a angesprochen.
print(a$dot) # Dieses gibt es dagegen nicht.
```

**Tip**: Wenn Du Verwirrungen mit anderen Sprachen minimieren willst,
verwendest Du den Punkt als Worttrenner nicht. Er ist eher eine Erblast als ein
Feature oder besonders R-stylisch. Die besseren Alternativen sind
*unter_strich* oder *CamelCase*.

### Zuweisungen

Kurz gesagt, die Zuweisung zu Variablen erfolgt in R mittels des
Zuweisungsoperators `<-`  während die Zuweisung zu Funktionsparametern und zu
Namen in Listen und Data-Frames mit dem Gleichheitszeichen `=` erfolgt.

Dieses Beispiel zeigt die Anwendung von `<-` und `=`.

```{r assignments}
##################################################
# Create a dataframe with calculated planet data.
#
# @param names Characters of names.
# @param radii Numbers of radii in km.
# @return data.frame
##
setupPlanets <- function(names, radii, star = "Sonne") {
     data.frame(
        Name = names,
        Star = star,
        Radius = radii,
        Diameter = 2 * radii,
        Perimeter = 2 * pi * radii,
        Surface = 4 * pi * radii^2,
        Volume =  4/3 * pi * radii^3
    )
 }

input <- list(
    names = c("Merkur", "Venus", "Erde", "Mars"),
    radii = c(2440, 6052, 6371, 3389)
)
planets <- setupPlanets(radii = input$radii, names = input$names)
print(planets)
```

Hier definiere ich eine Funktion und weise sie der Variablen `setupPlanets`
mittels des `<-`-Operators zu.  Das speichern ganzer Funktionen in Variablen
charakterisiert eine funktionale Programmiersprache. Eine solche Zuweisung
erfolgt auch bei den Variablen `input` und `planets`, denen eine Liste bzw.
einen Data-Frame zugewiesen wird.

Sowohl beim Data-Frame als auch bei der Liste werden die einzelnen benannten
Elemente mittels `=` zugewiesen.

Das Gleichheitszeichen verwende ich auch, um den Parameter `star` bei der
Funktionsdefinition mit einem Default-Wert vorzubelegen, hier `"Sonne"`.
Beim Funktionsaufruf dient mir das Gleichheitszeichen schließlich dazu, die
Parameter mit ihrem Namen statt mit ihrer Reihenfolge an zu sprechen.  Hier
habe ich die Reihenfolge vertauscht, um das zu demonstrieren.

#### Diskussion der Alternativen

Es ist oft, aber eben nicht immer, technisch möglich Variablen mittels `=`
statt mittels `<-` zuzuweisen. Weil das ein Zeichen weniger zu tippen ist und
den Zuweisungen in vielen anderen Programmiersprachen entspricht, wird Dir das
im Code vieler Leute begegnen. Um einen klaren, einheitlichen Programmierstil
zu pflegen, solltest Du aber konsequent `<-` für die Zuweisung von Variablen
benutzen. Das ist einfach R-stylisch.

Die Zuweisung mittels `<--` ist möglich, aber für die Zuweisung an
übergeordnete Sichtbarkeitsbereiche gedacht. Du musst wissen, was du hiermit
tust. Dazu mehr im Kapitel über die Sichtbarkeitsbereiche.

`->` macht genau dasselbe wie `<-`. Nicht dass Du denkst die Variable käme dann
nach rechts. Es ist also nicht intuitiv verständlich.

Analog ist `-->` dasselbe `<--` und nicht intuitiv verständlich.

Also:

* `=` Ist nicht überall einsetzbar und nicht R-stylisch.
* `->` Ist verwirrend.
* `<--` Du solltest wissen, was Du tust.
* `-->` Ist verwirrent und Du solltest wissen, was Du tust.

**Tip**: Variablenzuweisung mittels `<-` bevorzugen.

### Namensräume

Variablen können bereits Funktionen oder Daten enthalten, auch die aus
den Basis-Paketen und die aus den Bibliotheken, die Du lädst.

Du musst also
aufpassen, dass Du keine Namen von Funktionen oder Daten überschreibst,
jedenfalls nicht solche, die Du später noch verwenden willst.

Tust Du es doch, dann kannst du die Variablen der Pakte aber immer noch über
ihren Full Qualified Name ansprechen. Das kann einerseits lohnenswert sein, um
einen sprechenden Variablennamen wie "data" frei einsetzen zu können,
andererseits  kann es auch eingefleischte R-Benutzer verwirren, wenn der
vertraute Name "zweckentfremdet" wird.

```{r}
# Die Funktion print ist im Paket base
base::print("Hallo")
# Das Paket base ist per default geladen.
# Darum kann base::print() verkürzt angesprochen werden.
print("Hallo")
# Die Variable print wird hier mit einer Funktion definiert.
print <- function(...) { "Nope" }
# Was passiert jetzt?
print("Welt")
# Der Fully Qualified Name funktioniert weiterhin.
base::print("Welt")
# Definition aufheben.
remove(print)
# Jetzt wird wieder base::print() angesprochen.
print("Welt")
```

### Coding Guidelines

Es gibt keine verbindlichen Coding Guidlines für R, was sicherlich auch mit
dem freien Geist der Wissenschaft zusammenhängt. Gerade im Hinblick auf die
wachsenden Ansprüche an die Reproduzierbarkeit von Studien, werden Standards
aber auch hier wichtiger. Darum möchte ich ein paar Empfehlungen aussprechen,
die sich aus anderen Bereichen herleiten lassen.

Klarheit, Einheitlichkeit und Dokumentation sind Elemente, die Du in Deinem
Programmcode anstreben solltest. Klarheit und Einheitlichkeit helfen Dir und
anderen, sich schnell und einfach in Deinem Code zu orientieren. Dokumentation
hilft, die Gedanken nachzuvollziehen, die zu Deinen Programmlösungen führen.
Alles das hilft auch Bugs zu vermeiden, zu finden und zu fixen.

Unter Dokumentation verstehe ich zuerst die Wahl sprechender Namen für Deine
Variablen, zu allererst die der Funktionsnamen. Je mehr Dein Programmcode der
gesprochenen Sprache nahe kommt, desto weniger musst Du in zusätlichen
Kommentaren erklären. Kryptischer Programmcode ist kein Zeichen einer
überlegenen Intelligenz, wie in den Kinofilmen gezeigt, sondern von
suboptimalen Bezeichnern. Desto einfacher andere Deinen Code nachvollziehen
können, desto besser ist Deine Arbeit und desto weniger Fehler wird er
enthalten.

Es ist eine gute Idee, einheitlich englische Bezeichner zu verwenden. Erstens
hast Du dann niemals Probleme mit Umlauten, zweitens sind englische Bezeichner
fast immer kürzer als deutsche und drittens arbeitest Du heute zuhnemend in
internationalen Teams. Wenn Du aber deutsche Bezeichner benutzen willst, dann
solltest Du auch darin möglichst konsequent sein.

Auch wenn Dozenten Variablen wie x, y, z benutzen, sollte so etwas nicht in
Deinem Code vorkommen, sondern ganze Worte. Wichtig ist, dass Du die
Autovervollständigung Deines Editors kennen lernst, damit Du nicht jedes
Zeichen einzeln tippen musst. Das spart Zeit und Tippfehler.

Sprechende Bezeichner bestehen oft aus zwei oder noch mehr Worteilen. Darum ist
es wichtig, wie Du Diese zusammenfügst. Für eine gute Lesbarkeit haben sich
CamelCase oder die Benutzung des Unterstriches bewährt. Bei drei Wortteilen
spart CamelCase im Vergleich zwei Unterstriche an Zeilenlänge. Da Deine Zeilen
80 Zeichen im Regelfall nicht überschreiten sollten, halte ich CamelCase für
vorteilhafter.

```{r eval=FALSE}
################################################################################
# Diese Kommentarbalken sind 80 Zeichen lang.
################################################################################

speakingWordExample = "kürzer" # CamelCase, sehr gut.
speaking_word_example = "länger" # Unterstrich, auch gut.
speakingwordexample = "schwer lesbar" # mangelhaft
nswe = "Aküfi" # So sprichst Du hoffentlich nicht den ganzen Tag.
s = "wie in Mathe" # Jetzt versteht Dich nur noch der Prozessor.
```

80 Zeichen sind ein allgemeiner Richtwert, wie lang Programmzeilen sein
sollten. Damit kannst Du auf einem normalen Monitor gut zwei Dateien
nebeneinader öffnen inklusive Zeilennummern. Wenn Du professionell arbeitest,
ist ein solcher Split-View eher die Regel als die Ausnahme, besonders dann,
wenn Du Code und Tests side-by-side erstellst. Diese Breite ist auch im
Hinblick auf eine einfache Fokussierbarkeit des Textes wichtig. Bei längeren
Zeilen wird es anstrengend, beim Lesen in der richtigen Zeile zu bleiben.

Den Programmcode solltest Du entsprechend seiner Blocktiefe einrücken. Ob du
das mittels Leerzeichen oder Tabs tust, ist Geschmacksache. Beides hat vor und
Nachteile. Wichtig ist, dass Dein Team und Du hier eine einheitliche Richtlinie
festlegen, weil beides durcheinander schlecht funktioniert.

Der verbreitetste Standard bei den Einrückungen sind 8 Zeichen. Bei vier Ebenen
sind dann aber schon 32 von 80 Zeichen damit verbraucht. Wenn Du zuammengestzte
Worte als Bezeichner verwendest, bist schnell am Ende der Zeile. Was tun?

1. Gute Bezeichner sind wichtiger als tiefe Einrückungen. Ich halte darum vier
   Zeichen bei den Einrückungen für sinnvoller.
2. Verschachtelungen von 4 Tiefen sind in der Regel ein Zeichen von zu langen
   und komplexen Funktionen. Meist kannst Du dann ganze Code-Blöcke in eigene
   Funktionen auslagern und erhälst damit ein besseres Ergebnis. Funktionen
   sollten selten länger als zwanzig Zeilen sein.
3. Wenn der Platz nicht ausreicht, dann brich die Zeile um und rücke die zweite
   Zeile noch einmal eine Ebene ein. Du kannst in R aber nicht an beliebigen
   Stellen umbrechen, weil das Zeilenende als Semicolon fehlinterpretiert
   werden kann. So lange Du innerhalb einer geöffneten Klammer umbrichst, z.B.
   innerhalb der Funktionsparameter, erkennt R, dass hier kein Instruktionsende
   sein kann. Probiere einfach etwas herum, bis Du das routiniert meisterst.

Auch wenn Du konsequent ganze Worte als Variablennamen verwendest, solltest Du
immer noch Kommentare schreiben. Kommentare innerhalb von Funktionen sollten
dann aber so gut wie überflüssig werden. Oberhalb von Funktionen sollte ein
einheitlich formatierter Kommentar stehen, der in der Regel 4 Angaben macht:

1. Titel der Funktion
2. Beschreibung, was die Funktion tut (kann bei Banalitäten fehlen).
3. Beschreibung jedes einzelnen Parameters.
4. Rückgabewert der Funktion.

```{r eval=FALSE}
################################################################################
# Do nothing
#
# This function does nothing. It just exists,
# that you have something to call.
#
# @param Integer Defaults to 43.
# @param ...     Eats up any additional parameters that you feed into.
# @return NULL
##
doNothing <- function(dummy = 43, ...) {
    NULL
}
```

Dein Code sieht aufgeräumt aus, wenn du wie in diesem Beispiel einen
einheitlichen Rahmen um den Funktionskommentar zeichnest. Ich wähle auch hier
eine Länge von 80 Zeichen, um dem Leser eine Fokussionshilfe zu geben.

In R sind Funktionen, die in Variablen gespeicherst sind, zwar auch Objekte, In
dem Moment, in dem die sie aufrufst, werden sie aber akitiv. Sie sind die
Verben deines Programmcodes. Darum solltest Du sie auch immer mit Verben
bennen. Der Standard ist, dazu den Imperativ zu verwenden, so wie im
vorstehenden Beispiel `doNothing()`. Andere Beispiele wären `getName()`,
`setName()`, `createTable()`, `translateToSomeThing()`, `format()`,
`showResult()`.

Eine Ausnahme sind Funktionen, die `TRUE` oder `FALSE` zurück geben. Sie
werden am besten wie Fragen formuliert, so dass sie in `if`-Verzweigungen oder
`while`-Schleifen sprachlich Sinn ergeben.

```{r eval=FALSE}
if(isChild(person)) {
    print("Kein Zugang")
}

while(hasMoreElements(iterator)) {
    print(getNextElement(iterator))
}
```

Das Beispiel `doNothing()` zeigt auch, dass der erste Buchstabe immer klein
sein sollte, auch bei CamelCase. Das gilt sowohl für Werte als auch für
Funktionen. Eine sinnvolle Ausnahme sind Funktionen, die wie Klassen in
anderen Sprachen verwendet werden. Dazu später.

